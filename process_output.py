#!/usr/bin/env python

import sys
import re
import cgi
import os
import datetime
import csv

# this script parses the output of the JUnit tests for one submission.
# the output is read from the file "out.txt" in the submission folder.
# This output file is generated by running the script "runtest.py", 
#   e.g., "runtest.py $dir Lab2.java | tee s/$dir/out.txt"

def process_output_file(dir):
	java_file = "Account.java"
	stu_name = dir[:dir.find('_')]
	
	# is java file exists?
	header = [java_file,"Student","folder"]
	java_file_exists = os.path.exists("s/" + dir + "/" + java_file)
	line = [('0','1')[java_file_exists], stu_name, dir]
	if(not java_file_exists):
		return (line, header, [], [], [], "")
		
	# read the compiler output and java source code
	f = open("s/" + dir + "/out.txt", "r")
	output = f.read()
	
	f = open("s/" + dir + "/Account.java", "r")
	java_code = f.read()
	
	header += ["size"]
	line += [str(os.path.getsize("s/" + dir + "/" + java_file))]

	# verify the existance of for/while loops for recursive methods
#	header += ["for/while", "iterative_method"]
#	line += [is_there_for_while(java_code)]
#	line += [is_there_iterative_method(java_code)]

	# the deadline and cutoff dates
	deadline = datetime.datetime(2021, 03, 26, 0, 0, 0, 0)
	cutoffd  = datetime.datetime(2021, 03, 27, 0, 0, 0, 0)
	mtime = get_submission_timestamps(stu_name)
#	mtime = datetime.datetime.fromtimestamp(os.path.getmtime("s/" + dir + "/" + java_file))
	
	#
	is_grace = ("non-grace", "grace")[deadline <= mtime and mtime < cutoffd]
	is_late = ("non-late", "late")[cutoffd <= mtime]
	
	header += ["is_comp", "is_timeout", "submit_date", "is_grace", "is_late"]
	
	(is_comp, non_comp_detail) = is_compiled(output)
	line.append(("no-compile","compile")[is_comp])
	
	is_timeout = is_timedout(output)
	line.append(("no-timeout","timeout")[is_timeout])

	line.append(mtime.strftime("%Y-%m-%d %H:%M:%S"))
	line.append(is_grace)
	line.append(is_late)

	if(is_comp and not is_timeout):
		(testsR, testsH, testsF) = process_completed_tests(output)
		line.append(",".join(map(str, testsR)))
		header += testsH
	else:
		testsR = []
		testsH = []
		testsF = []

	return (line, header, testsR, testsH, testsF, non_comp_detail)

def is_compiled(output):
	fail_compile = "YOUR SUBMISSION FAILED TO COMPILE"
	failed_compile = re.findall(fail_compile, output, re.MULTILINE)
	if (len(failed_compile) > 0):
		return (False, output[output.find('Here is the compiler output:'):])

	return (True, "")

def is_timedout(output):
	pattern = "^Could not run testers within \d+ seconds: tester-timed-out!$"
	return len(re.findall(pattern, output, re.MULTILINE)) != 0

def process_completed_tests(output):
	n_failed = re.findall("^\[\s*(\d+)\stests failed\s*\]$", output, re.MULTILINE)
	n_passed = re.findall("^\[\s*(\d+)\stests successful\s*\]$", output, re.MULTILINE)
	n_found  = re.findall("^\[\s*(\d+)\stests found\s*\]$", output, re.MULTILINE)

	n_failed = int(n_failed[0]) if len(n_failed) > 0 else 0
	n_passed = int(n_passed[0]) if len(n_passed) > 0 else 0
	n_found  = int(n_found[0])  if len(n_found)  > 0 else 0

	if(n_found == 0):
		print(output)
		raise Exception("\033[91m---------- No testers found ------------\033[0m")
	
	all_tests = "^\s{4}[(\+|\')]\-\-\s(\w.*?)\(.*?\)\s*\[(X|OK)\](\s*?.*)$"
	all_tests = re.findall(all_tests, output, re.MULTILINE)

	n_pass = 0
	n_fail = 0
	test_result = ['1']*n_found
	i = 0
	for test in all_tests:
		t = test[1].strip()
		if(t == "OK"):
			n_pass += 1
		elif(t == "X"):
			n_fail += 1
			test_result[i] = '0'
		else:
			raise Exception("\033[91m------------- Known test result type -------------\033[0m")
		i += 1

	if not (n_failed == n_fail and n_pass == n_passed and n_found == (n_pass+n_fail)):
		print "n_failed {}, n_fail {}, n_pass {}, n_passed {}, n_found {}".format(n_failed, n_fail, n_pass, n_passed, n_found)
		raise Exception("\033[91m---------- None Matching Tests ------------\033[0m")

	return test_result, [test[0] for test in all_tests], [test[2] for test in all_tests] # result(0/1), header, fail_detial

def get_submission_timestamps(stu_name):
	with open("timestamps.csv", mode='r') as f:
		r = csv.reader(f)
		next(r)
		ts = {d[1]:datetime.datetime.strptime(d[7], "%A, %d %B %Y, %I:%M %p") for d in r if d[7] != "-"}
	return ts[stu_name]

#def is_there_for_while(contents):
#	for_loop_pattern = "^(?!(//))\s*(for\s*\(\s*\w+\s+(?!(i : arr)).*?\))"
#	while_loop_pattern = "^(?!(//))\s*while\s*\(\s*\w+.*?\)"
#	for_loop_loc = re.findall(for_loop_pattern, contents, re.MULTILINE)
#	while_loop_loc = re.findall(while_loop_pattern, contents, re.MULTILINE)
#	s = "for" if len(for_loop_loc) > 0 else "-"
#	s+= "/while" if len(while_loop_loc) > 0 else "/-"
#	return s
#
#def is_there_iterative_method(contents):
#	indexOf_pattern = "(indexOf|split|contains|replace)\s*\(.*?\)"
#	return "itm" if len(re.findall(indexOf_pattern, contents, re.MULTILINE)) > 0 else "-"

# the option "-l" is to print comma separated list of test case names. Used as the csv headers.
if __name__ == "__main__":

	if(len(sys.argv) < 2):
		print("Usage: {} <studentfolder> [-header]".format(sys.argv[0]))
		exit()

	(line, header, testsR, testsH, testsF, non_comp_detail) = process_output_file(sys.argv[1])

	if(len(sys.argv) > 2 and sys.argv[2] == "-header"):
		print(",".join(header))
	else:
		print(",".join(line))

		
